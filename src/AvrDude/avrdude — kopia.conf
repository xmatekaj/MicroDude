# AVRDUDE Configuration File                               -*- text -*-
#

avrdude_conf_version = "8.0";

# This file contains AVRDUDE's default configuration data describing
# programming hardware pinouts and part definitions. Normally, it
# requires AVRDUDE be of the same or higher version than above string.
# AVRDUDE's -C command line option specifies the location of the
# configuration file. The -c option names the programmer configuration
# which must match one of the entry's id parameter. The -p option
# identifies which part AVRDUDE is going to be programming and must
# match one of the parts' id parameters.
#
# DO NOT MODIFY THIS FILE.  Modifications will be overwritten the next
# time a "make install" is run.  For user-specific additions, use the
# "-C +filename" command line option.
#
# Possible entry formats are:
#
#   programmer
#       parent <id>                               # optional parent
#       id       = <id1> [, <id2> ... ] ;         # <idN> are quoted strings
#       desc     = <description> ;                # quoted string
#       type     = <type>;                        # programmer type, quoted string
#                                                 # list known types with -c ?type
#       prog_modes = PM_<i/f> {| PM_<i/f>}        # interfaces, eg, PM_SPM|PM_PDI (1)
#       is_serialadapter = <yes|no>               # programmer is also a serialadapter
#       extra_features = HAS_<fea> {| HAS_<fea>}  # extra features, eg, HAS_SUFFER (2)
#       connection_type = parallel | serial | usb | spi
#       baudrate = <num> ;                        # baudrate for avr910-programmer
#       vcc      = <pin1> [, <pin2> ... ] ;       # pin number(s) (3)
#       buff     = <pin1> [, <pin2> ... ] ;       # pin number(s)
#       reset    = <pin> ;                        # pin number
#       sck      = <pin> ;                        # pin number
#       sdo|pico = <pin> ;                        # pin number
#       sdi|poci = <pin> ;                        # pin number
#       tck      = <pin> ;                        # pin number
#       tdi      = <pin> ;                        # pin number
#       tdo      = <pin> ;                        # pin number
#       tms      = <pin> ;                        # pin number
#       errled   = <pin> ;                        # pin number
#       rdyled   = <pin> ;                        # pin number
#       pgmled   = <pin> ;                        # pin number
#       vfyled   = <pin> ;                        # pin number
#       usbvid   = <hexnum> ;                     # USB vendor ID
#       usbpid   = <hexnum> [, <hexnum> ...] ;    # USB product ID (4)
#       usbdev   = <interface> ;                  # USB interface or other device info
#       usbvendor = <vendorname> ;                # USB Vendor Name
#       usbproduct = <productname> ;              # USB Product Name
#       usbsn    = <serialno> ;                   # USB Serial Number
#       hvupdi_support = <num> [, <num>, ... ] ;  # UPDI HV Variants Support
#   ;
#
#   # Notes
#   #
#   # (1) The following program modes are known:
#   #  - PM_SPM: Bootloaders, self-programming with SPM opcodes or NVM Controllers
#   #  - PM_TPI: Tiny Programming Interface (t4, t5, t9, t10, t20, t40, t102, t104)
#   #  - PM_ISP: SPI programming for In-System Programming (almost all classic parts)
#   #  - PM_PDI: Program and Debug Interface (xmega parts)
#   #  - PM_UPDI: Unified Program and Debug Interface
#   #  - PM_HVSP: High Voltage Serial Programming (some classic parts)
#   #  - PM_HVPP: High Voltage Parallel Programming (most non-HVSP classic parts)
#   #  - PM_debugWIRE: Simpler alternative to JTAG (a subset of HVPP/HVSP parts)
#   #  - PM_JTAG: Joint Test Action Group standard (some classic parts)
#   #  - PM_JTAGmkI: Subset of PM_JTAG, older parts, Atmel ICE mkI
#   #  - PM_XMEGAJTAG: JTAG, some XMEGA parts
#   #  - PM_AVR32JTAG: JTAG for 32-bit AVRs
#   #  - PM_aWire: AVR32 parts
#   #
#   # (2) The following extra programmer features are known:
#   #  - HAS_SUFFER: Only present on Xplained Mini/Nano programmers.
#   #    The Super User Fantastic Feature Enable Register allows the user to modify
#   #    the behavior of the mEDBG programmer/debugger chip. See the Xplained Mini/Nano
#   #    documentation for more information
#   #  - HAS_VTARG_SWITCH: Programer has a programmable target power switch
#   #  - HAS_VTARG_READ: Programmer can read the target voltage
#   #  - HAS_VTARG_ADJ: Programmer has an adjustable target power source that can
#   #    be controlled with Avrdude
#   #  - HAS_FOSC_ADJ: Programmer has a programable frequency generator that
#   #    can clock an AVR directly through its XTAL1 pin
#   #  - HAS_VAREF_ADJ: Programmer has an adjustable analog reference voltage that
#   #    can be controlled with Avrdude
#   #
#   # (3) To invert the polarity of a pin use a tilde: ~<num>
#   #     To invert the polarity of all pins in a list use ~(<num1> [, <num2> ... ])
#   #
#   # (4) Not all programmer types can process a list of PIDs
#
#   serialadapter                                 # same as programmer albeit only for usb parameters
#       parent <id>                               # optional serialadapter or programmer parent
#       id       = <id1> [, <id2> ... ] ;         # <idN> are quoted strings
#       desc     = <description> ;                # quoted string
#       baudrate = <num> ;                        # optional default baudrate, eg, in .avrduderc
#       usbvid   = <hexnum> ;                     # USB vendor ID
#       usbpid   = <hexnum> [, <hexnum> ...] ;    # list of USB product IDs
#       usbsn    = <serialno> ;                   # USB Serial Number in per-user .avrduderc
#   ;
#
#   part
#       desc             = <description> ;        # quoted string, the long part name, eg, "ATmega328p"
#       id               = <id> ;                 # quoted string, normally an abbreviated part name
#       variants         = <str1> [, <str2> ...]; # quoted strings, each starts with "<alt-name>: ..."
#       family_id        = <id> ;                 # quoted string, eg, "megaAVR" or "tinyAVR"
#       prog_modes       = PM_<i/f> {| PM_<i/f>}  # interfaces, eg, PM_SPM|PM_ISP|PM_HVPP|PM_debugWIRE
#       mcuid            = <num>;                 # unique id in 0..2039 for 8-bit AVRs
#       archnum          = <num>;                 # avr-gcc architecture number for the part
#       n_interrupts     = <num>;                 # number of interrupts, used for vector bootloaders
#       n_page_erase     = <num>;                 # if set, number of pages erased during SPM erase
#       n_boot_sections  = <num>;                 # Number of boot sections
#       boot_section_size = <num>;                # Size of (smallest) boot section, if any
#       hvupdi_variant   = <num> ;                # numeric -1 (n/a) or 0..2
#       stk500_devcode   = <num> ;                # numeric
#       avr910_devcode   = <num> ;                # numeric
#       is_at90s1200     = <yes/no> ;             # AT90S1200 part
#       signature        = <num> <num> <num> ;    # signature bytes
#       usbpid           = <num> ;                # DFU USB PID
#       chip_erase_delay = <num> ;                # microseconds
#       reset            = dedicated | io ;
#       retry_pulse      = reset | sck ;
#       # STK500 parameters (parallel programming IO lines)
#       pagel            = <num> ;                # page load pin name in hex, eg, 0xD7
#       bs2              = <num> ;                # byte select 2 pin name in hex, eg, 0xA0
#       serial           = <yes/no> ;             # can use serial programming
#       parallel         = <yes/no/pseudo> ;      # can use parallel programming
#       # STK500v2 parameters, to be taken from Atmel's ATDF files
#       timeout          = <num> ;
#       stabdelay        = <num> ;
#       cmdexedelay      = <num> ;
#       synchloops       = <num> ;
#       bytedelay        = <num> ;
#       pollvalue        = <num> ;
#       pollindex        = <num> ;
#       predelay         = <num> ;
#       postdelay        = <num> ;
#       pollmethod       = <num> ;
#       hvspcmdexedelay  = <num> ;
#       # STK500v2 HV programming parameters, from ATDFs
#       pp_controlstack  = <num>, <num>, ... ;    # PP only
#       hvsp_controlstack = <num>, <num>, ... ;   # HVSP only
#       flash_instr      = <num>, <num>, <num> ;
#       eeprom_instr     = <num>, <num>, ... ;
#       hventerstabdelay = <num> ;
#       progmodedelay    = <num> ;                # PP only
#       latchcycles      = <num> ;
#       togglevtg        = <num> ;
#       poweroffdelay    = <num> ;
#       resetdelayms     = <num> ;
#       resetdelayus     = <num> ;
#       hvleavestabdelay = <num> ;
#       resetdelay       = <num> ;
#       synchcycles      = <num> ;                # HVSP only
#       chiperasepulsewidth = <num> ;             # PP only
#       chiperasepolltimeout = <num> ;
#       chiperasetime    = <num> ;                # HVSP only
#       programfusepulsewidth = <num> ;           # PP only
#       programfusepolltimeout = <num> ;
#       programlockpulsewidth = <num> ;           # PP only
#       programlockpolltimeout = <num> ;
#       # debugWIRE and/or JTAG ICE mkII parameters, also from ATDF files
#       allowfullpagebitstream = <yes/no> ;
#       enablepageprogramming = <yes/no> ;
#       idr              = <num> ;                # IO addr of IDR (OCD) reg
#       rampz            = <num> ;                # IO addr of RAMPZ reg
#       spmcr            = <num> ;                # mem addr of SPMC[S]R reg
#       eecr             = <num> ;                # mem addr of EECR reg
#       eind             = <num> ;                # mem addr of EIND reg
#       mcu_base         = <num> ;                # MCU control block in ATxmega devices
#       nvm_base         = <num> ;                # NVM controller in ATxmega devices
#       ocd_base         = <num> ;                # OCD module in AVR8X/UPDI devices
#       syscfg_base      = <num> ;                # Chip revision ID in AVR8X/UPDI devices
#       ocdrev           = <num> ;                # JTAGICE3 parameter from ATDF files
#       pgm_enable       = <instruction format> ;
#       chip_erase       = <instruction format> ;
#       # parameters for bootloaders
#       autobaud_sync    = <num> ;                # autobaud detection byte, default 0x30
#       factory_fcpu     = <num> ;                # F_CPU in Hz on reset and factory-set fuses
#
#       memory <memstr>
#           paged           = <yes/no> ;          # yes/no (flash of classic parts only)
#           offset          = <num> ;             # memory offset
#           size            = <num> ;             # bytes
#           page_size       = <num> ;             # bytes
#           num_pages       = <num> ;             # numeric
#           initval         = <num> ;             # factory setting of fuses and lockbits
#           bitmask         = <num> ;             # bits used (only in fuses and lockbits)
#           n_word_writes   = <num> ;             # TPI only: if set, number of words to write
#           min_write_delay = <num> ;             # micro-seconds
#           max_write_delay = <num> ;             # micro-seconds
#           readback        = <num> <num> ;       # pair of byte values
#           readback_p1     = <num> ;             # byte value (first component)
#           readback_p2     = <num> ;             # byte value (second component)
#           pwroff_after_write = <yes/no> ;       # yes/no
#           mode            = <num> ;             # STK500 v2 file parameter from ATDF files
#           delay           = <num> ;             #   "
#           blocksize       = <num> ;             #   "
#           readsize        = <num> ;             #   "
#           read            = <instruction format> ;
#           write           = <instruction format> ;
#           read_lo         = <instruction format> ;
#           read_hi         = <instruction format> ;
#           write_lo        = <instruction format> ;
#           write_hi        = <instruction format> ;
#           loadpage_lo     = <instruction format> ;
#           loadpage_hi     = <instruction format> ;
#           writepage       = <instruction format> ;
#       ;
#   ;
#
# If any of the above parameters are not specified, the default value
# of 0 is used for numerics (except for mcuid, hvupdi_variant, ocdrev,
# initval and bitmask, all of which default to -1, and for autobaud_sync
# which defaults to 0x30), or the empty string "" for string values. If
# a required parameter is left empty, AVRDUDE will complain. Almost all
# occurrences of numbers (with the exception of pin numbers and where
# they are separated by space, eg, in signature and readback) can also
# be given as simple expressions involving arithemtic and bitwise
# operators.
#
# Parts can also inherit parameters from previously defined parts
# using the following syntax. In this case specified integer and
# string values override parameter values from the parent part. New
# memory definitions are added to the definitions inherited from the
# parent. If, however, a new memory definition refers to an existing
# one of the same name for that part then, from v7.1, the existing
# memory definition is extended, and components overwritten with new
# values. Assigning NULL removes an inherited SPI instruction format,
# memory definition, control stack, eeprom or flash instruction, eg,
# as in memory "efuse" = NULL;
#
#   part parent <id>                              # quoted string
#       id               = <id> ;                 # quoted string
#       <any set of other parameters from the list above>
#     ;
#
# NOTES:
#   * Not all memories will implement all instructions
#   * AVR Fuse bits and Lock bits are implemented as a type of memory
#   * Example memories are:
#       "flash", "eeprom", "fuse", "lfuse" (low fuse), "hfuse" (high
#       fuse), "signature", "calibration", "lock"
#   * The memory specified on the avrdude command line must match
#     one of the memories defined for the specified chip
#   * The pwroff_after_write flag causes avrdude to attempt to
#     power the device off and back on after an unsuccessful write to
#     the affected memory area if VCC programmer pins are defined. If
#     VCC pins are not defined for the programmer, a message
#     indicating that the device needs a power-cycle is printed out.
#     This flag was added to work around a problem with the
#     at90s4433/2333's; see the at90s4433 errata at:
#
#     https://www.microchip.com/content/dam/mchp/documents/OTH/ProductDocuments/DataSheets/doc1042.pdf
#
# INSTRUCTION FORMATS
#
#    Instruction formats are specified as a comma separated list of
#    string values containing information (bit specifiers) about each
#    of the 32 bits of the instruction.  Bit specifiers may be one of
#    the following formats:
#
#       '1'  = the bit is always set on input as well as output
#
#       '0'  = the bit is always clear on input as well as output
#
#       'x'  = the bit is ignored on input and output and set as 0
#
#       'a'  = the bit is an address bit; from v 7.1 the bit-number
#              is set to match the right bit position for the
#              instruction to "just work"
#
#       'aN' = the bit is the Nth address bit, bit-number = N, i.e., a12
#              is address bit 12 on input, a0 is address bit 0.
#
#       'i'  = the bit is an input data bit (can optionally be followed
#              by a memory bit position between 0 and 7 if that differs
#              from the bit-position in the SPI write command byte)
#
#       'o'  = the bit is an output data bit (can optionally be followed
#              by a memory bit position between 0 and 7)
#
#    Each instruction must be composed of 32 bit specifiers. The
#    instruction specification closely follows the instruction data
#    provided in Atmel's data sheets for their parts. Note that flash
#    addresses always refer to *word* addresses whilst all other
#    memory types specify *byte* addresses.
#
#    Example for signature read on the ATmega328P:
#      read = "0 0 1 1 0 0 0 0",  "0 0 0 x x x x x",
#             "x x x x x x a1 a0",  "o o o o o o o o";
#
#   As the address bit numbers in the SPI opcodes are highly
#   systematic, they don't really need to be specified. A compact
#   version of the format specification neither uses bit-numbers for
#   address lines nor spaces. If such a string is longer than 7
#   characters, then the characters 0, 1, x, a, i and o will be
#   recognised as the corresponding bit, whilst any of the characters
#   ., -, _ or / can act as arbitrary visual separators, which are
#   ignored. Examples:
#
#     loadpage_lo = "0100.0000--000x.xxxx--xxaa.aaaa--iiii.iiii";
#
#     loadpage_lo = "0100.0000", "000x.xxxx", "xxaa.aaaa", "iiii.iiii";
#
#
# The following are STK500 part device codes to use for the
# stk500_devcode field of the part.  These came from Atmel's software
# section avr061.zip which accompanies the application note
# AVR061 available from:
#
#      https://ww1.microchip.com/downloads/en/Appnotes/doc2525.pdf
#

#define ATTINY10    0x10  /* the _old_ one that never existed! */
#define ATTINY11    0x11
#define ATTINY12    0x12
#define ATTINY15    0x13
#define ATTINY13    0x14

#define ATTINY22    0x20
#define ATTINY26    0x21
#define ATTINY28    0x22
#define ATTINY2313  0x23

#define AT90S1200   0x33

#define AT90S2313   0x40
#define AT90S2323   0x41
#define AT90S2333   0x42
#define AT90S2343   0x43

#define AT90S4414   0x50
#define AT90S4433   0x51
#define AT90S4434   0x52
#define ATMEGA48    0x59

#define AT90S8515   0x60
#define AT90S8535   0x61
#define AT90C8534   0x62
#define ATMEGA8515  0x63
#define ATMEGA8535  0x64

#define ATMEGA8     0x70
#define ATMEGA88    0x73
#define ATMEGA168   0x86

#define ATMEGA161   0x80
#define ATMEGA163   0x81
#define ATMEGA16    0x82
#define ATMEGA162   0x83
#define ATMEGA169   0x84

#define ATMEGA323   0x90
#define ATMEGA32    0x91

#define ATMEGA64    0xA0

#define ATMEGA103   0xB1
#define ATMEGA128   0xB2
#define AT90CAN128  0xB3
#define AT90CAN64   0xB3
#define AT90CAN32   0xB3

#define AT86RF401   0xD0

#define AT89START   0xE0
#define AT89S51     0xE0
#define AT89S52     0xE1

# The following table lists the devices in the original AVR910
# appnote:
# |Device |Signature | Code |
# +-------+----------+------+
# |tiny12 | 1E 90 05 | 0x55 |
# |tiny15 | 1E 90 06 | 0x56 |
# |       |          |      |
# | S1200 | 1E 90 01 | 0x13 |
# |       |          |      |
# | S2313 | 1E 91 01 | 0x20 |
# | S2323 | 1E 91 02 | 0x48 |
# | S2333 | 1E 91 05 | 0x34 |
# | S2343 | 1E 91 03 | 0x4C |
# |       |          |      |
# | S4414 | 1E 92 01 | 0x28 |
# | S4433 | 1E 92 03 | 0x30 |
# | S4434 | 1E 92 02 | 0x6C |
# |       |          |      |
# | S8515 | 1E 93 01 | 0x38 |
# | S8535 | 1E 93 03 | 0x68 |
# |       |          |      |
# |mega32 | 1E 95 01 | 0x72 |
# |mega83 | 1E 93 05 | 0x65 |
# |mega103| 1E 97 01 | 0x41 |
# |mega161| 1E 94 01 | 0x60 |
# |mega163| 1E 94 02 | 0x64 |

# Appnote AVR109 also has a table of AVR910 device codes, which
# lists:
# dev         avr910   signature
# ATmega8     0x77     0x1E 0x93 0x07
# ATmega8515  0x3B     0x1E 0x93 0x06
# ATmega8535  0x6A     0x1E 0x93 0x08
# ATmega16    0x75     0x1E 0x94 0x03
# ATmega162   0x63     0x1E 0x94 0x04
# ATmega163   0x66     0x1E 0x94 0x02
# ATmega169   0x79     0x1E 0x94 0x05
# ATmega32    0x7F     0x1E 0x95 0x02
# ATmega323   0x73     0x1E 0x95 0x01
# ATmega64    0x46     0x1E 0x96 0x02
# ATmega128   0x44     0x1E 0x97 0x02
#
# These codes refer to "BOOT" device codes which are apparently
# different than standard device codes, for whatever reasons
# (often one above the standard code).

# There are several extended versions of AVR910 implementations around
# in the Internet.  These add the following codes (only devices that
# actually exist are listed):

# ATmega8515    0x3A
# ATmega128     0x43
# ATmega64      0x45
# ATtiny26      0x5E
# ATmega8535    0x69
# ATmega32      0x72
# ATmega16      0x74
# ATmega8       0x76
# ATmega169     0x78

#
# Overall avrdude defaults; suitable for ~/.config/avrdude/avrdude.rc
#
default_parallel   = "lpt1";
default_serial     = "com1";
default_spi        = "";
# default_baudrate = 115200;
# default_bitclock = 2.5;
default_linuxgpio  = "unknown";
allow_subshells    = no;







#
# PROGRAMMER DEFINITIONS
#

#------------------------------------------------------------
# dryrun
#------------------------------------------------------------

# Using -c dryrun is a good way to get acquainted with AVRDUDE and its
# command line -U memory operations, -T terminal commands or the
# interactive terminal -t. No hardware needs to be connected, as the
# dryrun programmer emulates what can be expected to happen with a real
# -c programmer and a corresponding connected physical programmer or a
# directly connected board when it has a bootloader.
#
# Examples:
# avrdude -c dryrun -p ATmega328P -t # Interactive terminal: enter help
# avrdude -c dryrun -p ATmega2560 -U flash:w:myapplication.hex:i
# avrdude -c dryrun -p AVR64DB48 -Tconfig

programmer # dryrun
    id                     = "dryrun";
    desc                   = "Emulates programming without a programmer";
    type                   = "dryrun";
    prog_modes             = PM_TPI | PM_ISP | PM_PDI | PM_UPDI | PM_HVSP | PM_HVPP | PM_aWire;
;

#------------------------------------------------------------
# dryboot
#------------------------------------------------------------

# Like -c dryrun the -c dryboot programmer only emulates programming,
# albeit for communicating to bootloaders, ie, without a physical
# programmer between the host and the target AVR part. AVRDUDE behaves
# slightly different when talking to a bootloader: Whilst for most classic
# parts the flash memory looks like NOR-memory, ie, cleared bits cannot be
# set and therefore programming requires a chip erase first, bootloaders
# do have the power of erasing a flash page (setting it to all 0xff)
# before writing a page. This requires AVRDUDE to behave differently when
# talking to a bootloader, which it recognises by the prog_modes = PM_SPM
# setting below. -c dryboot allows exploring these differences at an
# emulation level.

programmer # dryboot
    id                     = "dryboot";
    desc                   = "Emulates bootloader programming without the part";
    type                   = "dryrun";
    prog_modes             = PM_SPM;
;

#------------------------------------------------------------
# wiring
#------------------------------------------------------------

# http://wiring.org.co/
# Basically STK500v2 protocol, with some glue to trigger the bootloader

programmer # wiring
    id                     = "wiring";
    desc                   = "Wiring bootloader using STK500 v2 protocol";
    type                   = "wiring";
    prog_modes             = PM_SPM;
    connection_type        = serial;
;

#------------------------------------------------------------
# arduino
#------------------------------------------------------------

# Serves optiboot bootloaders and others using the STK500v1 protocol;
# it is superseded by the more modern -c urclock programmer, see below.
# The programmer is named after the popular embedded programming
# environment Arduino that has for a long time used optiboot
# bootloaders. Same as the stk500v1 except that it resets the attached
# board and treats EEPROM as the optiboot bootloaders expect.

programmer # arduino
    id                     = "arduino";
    desc                   = "Arduino bootloader using STK500 v1 protocol";
    type                   = "arduino";
    prog_modes             = PM_SPM;
    connection_type        = serial;
;

#------------------------------------------------------------
# urclock
#------------------------------------------------------------

# Serves urboot and optiboot bootloaders
#  - Reads/writes flash/EEPROM via the MCU bootloader and a serial connection
#  - Automatically resets an attached board via RTS/DTR into bootloader mode
#  - Implements urprotocol, a skeleton version of STK500v1
#  - Supports vector bootloaders by patching interrupt vectors on flash writes
#     + Vector bootloaders run on all parts, no need for a HW boot section
#     + Can be much smaller than the smallest HW boot section of a part, eg,
#       256 bytes for ATmega2560 (smallest HW boot section is 1024 bytes)
#  - Checks sizes of applications so they don't overwrite the bootloader
#  - Keeps the bootloader alive during interactive terminal sessions
#  - Provides a 4-byte metadata interface in top flash for
#     + Allowing applications to utilise unused flash similar to EEPROM
#     + Storing in top flash the file name and its last-modified date
#     + Displaying file name and date of the last programmed application
#
# See https://github.com/stefanrueger/urboot

programmer # urclock
    id                     = "urclock";
    desc                   = "Urboot bootloaders using urprotocol";
    type                   = "urclock";
    prog_modes             = PM_SPM;
    connection_type        = serial;
;

#------------------------------------------------------------
# xbee
#------------------------------------------------------------

# The XBeeBoot bootloader provides XBee Series 2 Over-The-Air
# firmware update capability as well as supporting direct
# firmware update via the stk500v1 protocol. See
# https://github.com/davidsainty/xbeeboot
# for details.

programmer # xbee
    id                     = "xbee";
    desc                   = "XBeeBoot Over-The-Air bootloader (STK500 v1)";
    type                   = "xbee";
    prog_modes             = PM_SPM;
    connection_type        = serial;
;

#------------------------------------------------------------
# ft2232h
#------------------------------------------------------------

# FTDI USB to serial converters can be used for ISP programming of
# classic AVRs, and quite a few programmers are based on this. The
# ft2232h programmer, named after the FTDI converter chip,
# interfaces with the chips on these programmers (and more):
#  - http://real.kiev.ua/old/avreal/en/adapters
#  - http://www.amontec.com/jtagkey.shtml and .../jtagkey-tiny.shtml
#  - http://www.olimex.com/dev/arm-usb-ocd.html, arm-usb-tiny.html
#  - http://www.ethernut.de/en/hardware/turtelizer/index.html
#  - https://web.archive.org/web/20161221220118/http://elk.informatik.fh-augsburg.de/hhweb/doc/openocd/usbjtag/usbjtag.html
#  - http://dangerousprototypes.com/docs/FT2232_breakout_board
#  - http://flashrom.org/FT2232SPI_Programmer
#
# The programmer will look for a specific device and use the first
# one found. If you have multiple devices, and they give out serial
# numbers, a different entry for each of them can be created in a
# per-user ~/.avrduderc or avrdude.rc entry and the usbsn = "...";
# field added to distinguish between them.
#
# Avrftdi-type programmers utilise the Multi-Protocol Synchronous Serial
# Engine (MPSSE) of the FTDI ICs, which determines the pin numbers for the
# main ISP signals (sck, sdo, sdi). The reset pin can differ, though.
#
# Data sheet of the FT2232H chip:
#   https://ftdichip.com/wp-content/uploads/2020/08/DS_FT2232H.pdf

programmer # avrftdi
    id                     = "avrftdi", "2232h";
    desc                   = "FT2232H/D based generic programmer";
    type                   = "avrftdi";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x0403;
    usbpid                 = 0x6010;
    usbdev                 = "A";
# ISP-signals - lower ADBUS-Nibble (default)
    reset                  = 3; # AD3 (TMS)
    sck                    = 0; # AD0 (TCK)
    sdo                    = 1; # AD1 (TDI)
    sdi                    = 2; # AD2 (TDO)
;

#------------------------------------------------------------
# ft2232h
#------------------------------------------------------------

# The ft2232h programmer is the same as above 2232h but it can be
# used to address the port of a particular board via -P ft2232h

programmer parent "2232h" # ft2232h
    id                     = "ft2232h";
    is_serialadapter       = yes;
;

#------------------------------------------------------------
# 2232HIO
#------------------------------------------------------------

# This is an implementation of the above 2232h with a buffer IC
# (74AC244) and 4 LEDs directly attached, all active low.

programmer parent "2232h" # 2232hio
    id                     = "2232hio";
    desc                   = "2232hio based on FT2232H with buffer and LEDs";
    buff                   = ~4;
# LED SIGNALs
    errled                 = ~11;
    rdyled                 = ~14;
    pgmled                 = ~13;
    vfyled                 = ~12;
;

#------------------------------------------------------------
# tigard
#------------------------------------------------------------

# Tigard - FT2232H based multi-protocol tool for hardware hacking
# https://github.com/tigard-tools/tigard

programmer parent "2232h" # tigard
    id                     = "tigard";
    desc                   = "Tigard interface board";
    usbdev                 = "B";
# Reset is different to the FT2232H; sck, sdo, sdi remain at 0, 1, 2
    reset                  = 5; # BD5 (GPIOL1)
;

#------------------------------------------------------------
# avrisp-u
#------------------------------------------------------------

# Kanda's low cost FT2232H based programmer. Uses a different reset pin.
# Adds a buffer and a LED indicating that the programming is in progress.
# https://www.kanda.com/products/Kanda/AVRISP-U.html

programmer parent "2232h" # avrisp-u
    id                     = "avrisp-u";
    desc                   = "Kanda AVRISP-U";
    usbsn                  = "AVR";
    buff                   = ~5;
    reset                  = 4;
    pgmled                 = ~10;
;

#------------------------------------------------------------
# ft2232h_jtag
#------------------------------------------------------------

# Here a FTDI ft2232h chip is used for JTAG programming.

programmer # ft2232h_jtag
    id                     = "ft2232h_jtag";
    desc                   = "FT2232H based generic JTAG programmer";
    type                   = "avrftdi_jtag";
    prog_modes             = PM_JTAG;
    connection_type        = usb;
    usbvid                 = 0x0403;
    usbpid                 = 0x6010;
    usbdev                 = "A";
# JTAG-signals - lower ADBUS-Nibble (default)
    tck                    = 0; # AD0 (TCK)
    tdi                    = 1; # AD1 (TDI)
    tdo                    = 2; # AD2 (TDO)
    tms                    = 3; # AD3 (TMS)
;

#------------------------------------------------------------
# ft4232h
#------------------------------------------------------------

# The FT4232H can be treated as FT2232H but with a different USB
# device ID of 0x6011

programmer parent "ft2232h" # ft4232h
    id                     = "ft4232h";
    desc                   = "FT4232H based generic programmer";
    usbpid                 = 0x6011;
;

#------------------------------------------------------------
# 4232h
#------------------------------------------------------------

programmer parent "2232h" # 4232h
    id                     = "4232h";
    desc                   = "FT4232H based generic programmer";
    usbpid                 = 0x6011;
;

#------------------------------------------------------------
# jtagkey
#------------------------------------------------------------

programmer # jtagkey
    id                     = "jtagkey";
    desc                   = "Amontec JTAGKey/JTAGKey-Tiny/JTAGKey2";
    type                   = "avrftdi";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x0403;
#   Note: This PID is used in all JTAGKey variants
    usbpid                 = 0xcff8;
    usbdev                 = "A";
    buff                   = ~4;
#   ISP-signals => 20 - Pin connector on JTAGKey
#   The colours are on the 20 pin breakout cable from Amontec
    reset                  = 3; # TMS 7 violet
    sck                    = 0; # TCK 9 white
    sdo                    = 1; # TDI 5 green
    sdi                    = 2; # TDO 13 orange
#   VTG           VREF 1 brown with red tip
#   GND           GND 20 black
;

#------------------------------------------------------------
# ft232h
#------------------------------------------------------------

programmer # ft232h
    id                     = "ft232h";
    desc                   = "FT232H based generic programmer";
    type                   = "avrftdi";
    prog_modes             = PM_TPI | PM_ISP;
    is_serialadapter       = yes;
    connection_type        = usb;
    usbvid                 = 0x0403;
    usbpid                 = 0x6014;
    usbdev                 = "A";
# ISP-signals
    reset                  = 3; # AD3 (TMS)
    sck                    = 0; # AD0 (TCK)
    sdo                    = 1; # AD1 (TDI)
    sdi                    = 2; # AD2 (TDO)
;

#------------------------------------------------------------
# ft232h_jtag
#------------------------------------------------------------

programmer # ft232h_jtag
    id                     = "ft232h_jtag";
    desc                   = "FT232H based generic JTAG programmer";
    type                   = "avrftdi_jtag";
    prog_modes             = PM_JTAG;
    connection_type        = usb;
    usbvid                 = 0x0403;
    usbpid                 = 0x6014;
    usbdev                 = "A";
# JTAG-signals
    tck                    = 0; # AD0 (TCK)
    tdi                    = 1; # AD1 (TDI)
    tdo                    = 2; # AD2 (TDO)
    tms                    = 3; # AD3 (TMS)
;

#------------------------------------------------------------
# um232h
#------------------------------------------------------------

# Pin J2-7 (AD0) is SCK
# Pin J2-8 (AD1) is SDO
# Pin J2-9 (AD2) is SDI
# Pin J2-10 (AD3) is RESET
# Pin J2-6 is GND
# Use the -b flag to set the SPI clock rate eg -b 3750000 is the fastest I could get
# a 16MHz Atmega1280 to program reliably.  The 232H is conveniently 5V tolerant.

programmer parent "ft232h" # um232h
    id                     = "um232h";
    desc                   = "UM232H module from FTDI";
    is_serialadapter       = no;
;

#------------------------------------------------------------
# c232hm
#------------------------------------------------------------

# Orange (Pin 2) is SCK
# Yellow (Pin 3) is SDO
# Green (Pin 4) is SDI
# Brown (Pin 5) is RESET
# Black (Pin 10) is GND
# Use the -b flag to set the SPI clock rate eg -b 3750000 is the fastest I could get
# a 16MHz Atmega1280 to program reliably.  The 232H is conveniently 5V tolerant.

programmer parent "um232h" # c232hm
    id                     = "c232hm";
    desc                   = "C232HM cable from FTDI";
;

#------------------------------------------------------------
# o-link
#------------------------------------------------------------

# On the adapter you can read "O-Link". On the PCB is printed "OpenJTAG v3.1".
# You can find it as "OpenJTAG ARM JTAG USB" in the internet. Note there are also
# several projects called Open JTAG, which are completely different. Some other
# sources call it O-Link or just have a look at ebay ... It is basically the same
# entry as jtagkey with different usb ids. See www.100ask.net

programmer parent "jtagkey" # o-link
    id                     = "o-link";
    desc                   = "O-Link, OpenJTAG ARM JTAG USB";
    usbvid                 = 0x1457;
    usbpid                 = 0x5118;
    usbvendor              = "www.100ask.net";
    usbproduct             = "USB<=>JTAG&RS232";
;

#------------------------------------------------------------
# openmoko
#------------------------------------------------------------

# http://wiki.openmoko.org/wiki/Debug_Board_v3

programmer # openmoko
    id                     = "openmoko";
    desc                   = "Openmoko debug board (v3)";
    type                   = "avrftdi";
    prog_modes             = PM_TPI | PM_ISP;
    usbvid                 = 0x1457;
    usbpid                 = 0x5118;
    usbdev                 = "A";
    reset                  = 3; # TMS 7
    sck                    = 0; # TCK 9
    sdo                    = 1; # TDI 5
    sdi                    = 2; # TDO 13
;

#------------------------------------------------------------
# lm3s811
#------------------------------------------------------------

# Only Rev. A boards.
# Schematic and user manual: http://www.cs.put.poznan.pl/wswitala/download/pdf/811EVBK.pdf

programmer # lm3s811
    id                     = "lm3s811";
    desc                   = "Luminary Micro LM3S811 Eval Board (Rev. A)";
    type                   = "avrftdi";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x0403;
    usbpid                 = 0xbcd9;
    usbdev                 = "A";
    usbvendor              = "LMI";
    usbproduct             = "LM3S811 Evaluation Board";
# Enable correct buffers
    buff                   = 7;
# ISP-signals - lower ACBUS-Nibble (default)
    reset                  = 3;
    sck                    = 0;
    sdo                    = 1;
    sdi                    = 2;
;

#------------------------------------------------------------
# tumpa
#------------------------------------------------------------

# First SPI connector
# User manual: https://www.tiaowiki.com/w/TIAO_USB_Multi_Protocol_Adapter_User%27s_Manual

programmer parent "2232h" # tumpa
    id                     = "tumpa";
    desc                   = "TIAO USB Multi-Protocol Adapter";
    usbpid                 = 0x8a98;
    usbvendor              = "TIAO";
;

#------------------------------------------------------------
# tumpa-b
#------------------------------------------------------------

# Second SPI connector

programmer parent "tumpa" # tumpa-b
    id                     = "tumpa-b";
    usbdev                 = "B";
;

#------------------------------------------------------------
# tumpa_jtag
#------------------------------------------------------------

programmer parent "ft2232h_jtag" # tumpa_jtag
    id                     = "tumpa_jtag";
    desc                   = "TIAO USB Multi-Protocol Adapter in JTAG mode";
    usbpid                 = 0x8a98;
    usbvendor              = "TIAO";
    buff                   = ~11;
    reset                  = 4; # RST AD4 (Pin 15)
;

#------------------------------------------------------------
# ktlink
#------------------------------------------------------------

# Kristech KT-LINK FT2232H interface with IO switching and voltage buffers.
# Created on 20220410 by CeDeROM Tomasz CEDRO (www.cederom.io).
# Interface DataSheet: https://kristech.pl/files/KT-LINK-UM-ENG.pdf
#
# AVRDUDE FT2232H PIN NUMBER DECODE:
#  | 0      | 1      | .. | 7      | 8      | 9      | .. | 15     |
#  | ADBUS0 | ADBUS1 | .. | ADBUS7 | ACBUS0 | ACBUS1 | .. | ACBUS7 |
#
# KT-LINK JTAG CONN:
#  1=Vsense(->EXT13), 19=5V(EXT1->EXT3), 20=GND, 3=TPIRST, 9=TPICLK, 7=TPIDATA.
#
# INTERNALS CONFIGURATION ("~" MEANS ACTIVE LOW):
#  ~TRST_EN=10(ACBUS2), ~CLK_EN=14(ACBUS6), ~SDO_EN=13(ACBUS5),
#  TMS_SEL=5(ADBUS5), ~TMS_EN=12(ACBUS4), LED=~15(ACBUS7).
#
# CONNECTION NOTES:
#  * Connect EXT connector pin 1 with 3 to get 5V on JTAG connector pin 19.
#  * Connect JTAG connector pin 1 to 5V (i.e. EXT pin 13 or JTAG pin 19).
#  * For TPI connection use resistors: TDO --[470R]-- TPIDATA --[470R]-- TDI.
#  * Powering target from JTAG pin 19 allows KT-LINK current measurement.

programmer # ktlink
    id                     = "ktlink";
    desc                   = "KT-LINK FT2232H: IO switching, voltage buffers";
    type                   = "avrftdi";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x0403;
    usbpid                 = 0xbbe2;
    usbdev                 = "A";
    buff                   = 5, ~10, ~13, ~14;
    reset                  = 8;
    sck                    = 0;
    sdo                    = 1;
    sdi                    = 2;
    rdyled                 = ~15;
;

#------------------------------------------------------------
# digilent-hs2
#------------------------------------------------------------

# Digilent JTAG HS2 programmer. FT232H-based dongle with buffers.
# https://digilent.com/reference/_media/reference/programmers/jtag-hs2/jtag-hs2_rm.pdf

programmer # digilent-hs2
    id                     = "digilent-hs2";
    desc                   = "Digilent JTAG HS2 (MPSSE)";
    type                   = "avrftdi";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x0403;
    usbpid                 = 0x6014;
    usbdev                 = "A";
    buff                   = 5, 6, 7;
    reset                  = 3;
    sck                    = 0;
    sdo                    = 1;
    sdi                    = 2;
;

#------------------------------------------------------------
# flyswatter2
#------------------------------------------------------------

# FT2232H based JTAG programmer. Requires a buff pin to be set.
# https://www.tincantools.com/flyswatter2

programmer # flyswatter2
    id                     = "flyswatter2";
    desc                   = "TinCan Tools Flyswatter 2";
    type                   = "avrftdi";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x0403;
    usbpid                 = 0x6010;
    usbdev                 = "A";
    usbvendor              = "TinCanTools";
    usbproduct             = "Flyswatter2";
    buff                   = ~6;
    reset                  = 3;
    sck                    = 0;
    sdo                    = 1;
    sdi                    = 2;
    rdyled                 = ~11;
    pgmled                 = ~12;
;

#------------------------------------------------------------
# serialupdi
#------------------------------------------------------------

# The SerialUPDI programmer implementation is based on the
# Microchip pymcuprog utility. In a nutshell, this programmer
# consists of simple USB->UART adapter, diode and couple of
# resistors. It uses serial connection to provide UPDI interface.
# See https://github.com/microchip-pic-avr-tools/pymcuprog
# for details.

programmer # serialupdi
    id                     = "serialupdi";
    desc                   = "SerialUPDI";
    type                   = "serialupdi";
    prog_modes             = PM_UPDI;
    connection_type        = serial;
    hvupdi_support         = 1;
;

#------------------------------------------------------------
# serprog
#------------------------------------------------------------

# The Serprog programmer implementation allows programming
# with programmers using the serprog protocol from flashrom.
# See https://flashrom.org/supported_hw/supported_prog/serprog/overview.html
# and https://flashrom.org/supported_hw/supported_prog/serprog/serprog-protocol.html
# for details.

programmer # serprog
    id                     = "serprog";
    desc                   = "Program via the Serprog protocol from Flashrom";
    type                   = "serprog";
    prog_modes             = PM_ISP;
    connection_type        = serial;
;

#------------------------------------------------------------
# avrisp
#------------------------------------------------------------

# The original RS232 based Atmel AVR ISP programmer

programmer # avrisp
    id                     = "avrisp";
    desc                   = "Serial Atmel AVR ISP using STK500";
    type                   = "stk500";
    prog_modes             = PM_ISP;
    connection_type        = serial;
;

#------------------------------------------------------------
# avrispv2
#------------------------------------------------------------

programmer # avrispv2
    id                     = "avrispv2";
    desc                   = "Serial Atmel AVR ISP using STK500v2";
    type                   = "stk500v2";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = serial;
;

#------------------------------------------------------------
# avrispmkII
#------------------------------------------------------------

# Atmel AVR ISP mkII programmer. See
# https://www.microchip.com/en-us/development-tool/atavrisp2
# for details.

programmer # avrispmkII
    id                     = "avrispmkII", "avrisp2";
    desc                   = "USB Atmel AVR ISP mkII";
    type                   = "stk500v2";
    prog_modes             = PM_TPI | PM_ISP | PM_PDI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2104;
;

#------------------------------------------------------------
# buspirate
#------------------------------------------------------------

# Bus Pirate in AVR programming mode (hardware v3 and v4).
# See http://dangerousprototypes.com/docs/Bus_Pirate
# for details.
#
# PIN  ISP
# > 1  GND
#   2  (3.3V)
#   3  (5.0V)
#   4
#   5
#   6  (XTAL1)
#   7  SCK
#   8  SDO
#   9  RST
#  10  SDI

programmer # buspirate
    id                     = "buspirate";
    desc                   = "The Bus Pirate in AVR programming mode";
    type                   = "buspirate";
    prog_modes             = PM_ISP;
    connection_type        = serial;
;

#------------------------------------------------------------
# buspirate_bb
#------------------------------------------------------------

# Bus pirate in bit banging mode (hardware v3 and v4).

programmer # buspirate_bb
    id                     = "buspirate_bb";
    desc                   = "The Bus Pirate in bitbang mode";
    type                   = "buspirate_bb";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = serial;
  # pins are bits in bitbang byte (numbers are 87654321)
  # 1|POWER|PULLUP|AUX|SDO|CLK|SDI|CS
    reset                  = 1;
    sck                    = 3;
    sdo                    = 4;
    sdi                    = 2;
  # vcc                    = 7; # Internally set independent of this setting
;

#------------------------------------------------------------
# stk500
#------------------------------------------------------------

# This is supposed to be the "default" STK500 entry.
# Attempts to select the correct firmware version
# by probing for it.  Better use one of the entries
# below instead.

programmer # stk500
    id                     = "stk500";
    desc                   = "Atmel STK500 (probes v2 first then v1)";
    type                   = "stk500generic";
    prog_modes             = PM_ISP;
    extra_features         = HAS_VTARG_ADJ | HAS_VTARG_READ | HAS_FOSC_ADJ | HAS_VAREF_ADJ;
    connection_type        = serial;
;

#------------------------------------------------------------
# stk500v1
#------------------------------------------------------------

# The original STK500 protocol. Used by the Arduino as ISP
# programmer and various bootloaders.
# See AVR061 for details.

programmer # stk500v1
    id                     = "stk500v1";
    desc                   = "Atmel STK500 v1";
    type                   = "stk500";
    prog_modes             = PM_ISP;
    extra_features         = HAS_VTARG_ADJ | HAS_VTARG_READ | HAS_FOSC_ADJ | HAS_VAREF_ADJ;
    connection_type        = serial;
;

#------------------------------------------------------------
# arduino_as_isp
#------------------------------------------------------------

# Not to be confused with arduinoISP, this is the same as `-c stk500v1`
# but treats EEPROM r/w correctly for arduino_as_isp programmers
# See https://docs.arduino.cc/built-in-examples/arduino-isp/ArduinoISP/
# for details.

programmer # arduino_as_isp
    id                     = "arduino_as_isp";
    desc                   = "AVR as programmer with Arduino-as-ISP FW";
    type                   = "stk500";
    prog_modes             = PM_ISP;
    connection_type        = serial;
    baudrate               = 19200;
;

#------------------------------------------------------------
# mib510
#------------------------------------------------------------

# The MIB510 is a serial gateway that can program AVRs over
# ISP or TPI using the stk500v1 protocol. See
# http://www.cmt-gmbh.de/Produkte/WirelessSensorNetworks/MIB510.html
# for details.

programmer # mib510
    id                     = "mib510";
    desc                   = "Crossbow MIB510 programming board";
    type                   = "stk500";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = serial;
;

#------------------------------------------------------------
# stk500v2
#------------------------------------------------------------

# Version 2 of the STK500 protocol. See AVR068 for details.

programmer # stk500v2
    id                     = "stk500v2", "scratchmonkey";
    desc                   = "Atmel STK500 v2";
    type                   = "stk500v2";
    prog_modes             = PM_TPI | PM_ISP;
    extra_features         = HAS_VTARG_ADJ | HAS_VTARG_READ | HAS_FOSC_ADJ | HAS_VAREF_ADJ;
    connection_type        = serial;
;

#------------------------------------------------------------
# stk500pp
#------------------------------------------------------------

programmer # stk500pp
    id                     = "stk500pp", "scratchmonkey_pp";
    desc                   = "Atmel STK500 v2 in parallel programming mode";
    type                   = "stk500pp";
    prog_modes             = PM_HVPP;
    extra_features         = HAS_VTARG_ADJ | HAS_VTARG_READ | HAS_FOSC_ADJ | HAS_VAREF_ADJ;
    connection_type        = serial;
;

#------------------------------------------------------------
# stk500hvsp
#------------------------------------------------------------

programmer # stk500hvsp
    id                     = "stk500hvsp", "scratchmonkey_hvsp";
    desc                   = "Atmel STK500 v2 in HV serial programming mode";
    type                   = "stk500hvsp";
    prog_modes             = PM_HVSP;
    extra_features         = HAS_VTARG_ADJ | HAS_VTARG_READ | HAS_FOSC_ADJ | HAS_VAREF_ADJ;
    connection_type        = serial;
;

#------------------------------------------------------------
# stk600
#------------------------------------------------------------

# STK600 development board. See
# https://www.microchip.com/en-us/development-tool/atstk600
# and AVR079 for details.

programmer # stk600
    id                     = "stk600";
    desc                   = "Atmel STK600";
    type                   = "stk600";
    prog_modes             = PM_TPI | PM_ISP | PM_PDI;
    extra_features         = HAS_VTARG_ADJ | HAS_VTARG_READ | HAS_FOSC_ADJ | HAS_VAREF_ADJ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2106;
;

#------------------------------------------------------------
# stk600pp
#------------------------------------------------------------

programmer # stk600pp
    id                     = "stk600pp";
    desc                   = "Atmel STK600 in parallel programming mode";
    type                   = "stk600pp";
    prog_modes             = PM_HVPP;
    extra_features         = HAS_VTARG_ADJ | HAS_VTARG_READ | HAS_FOSC_ADJ | HAS_VAREF_ADJ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2106;
;

#------------------------------------------------------------
# stk600hvsp
#------------------------------------------------------------

programmer # stk600hvsp
    id                     = "stk600hvsp";
    desc                   = "Atmel STK600 in HV serial programming mode";
    type                   = "stk600hvsp";
    prog_modes             = PM_HVSP;
    extra_features         = HAS_VTARG_ADJ | HAS_VTARG_READ | HAS_FOSC_ADJ | HAS_VAREF_ADJ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2106;
;

#------------------------------------------------------------
# avr910
#------------------------------------------------------------

# The AVR910 is a programmer implementation based on the
# AVR910 application note.

programmer # avr910
    id                     = "avr910";
    desc                   = "Atmel Low Cost Serial Programmer";
    type                   = "avr910";
    prog_modes             = PM_ISP;
    connection_type        = serial;
;

#------------------------------------------------------------
# ft245r
#------------------------------------------------------------

# Ftdi_syncbb-type programmers utilise FTDI chips for programming
# in a bit-banging mode. In contrast to avrftdi-type programmers,
# the pin mapping to the main ISP signals (reset, sck, sdo, sdi) is
# somewhat arbitrary and will be determined by the actual routing
# of the FTDI IC pins to the ISP header of the physical programmer.

programmer # ft245r
    id                     = "ft245r";
    desc                   = "FT245R based generic programmer";
    type                   = "ftdi_syncbb";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x0403;
    usbpid                 = 0x6001;
    reset                  = 4; # D4
    sck                    = 0; # D0
    sdo                    = 2; # D2
    sdi                    = 1; # D1
;

#------------------------------------------------------------
# ft232r
#------------------------------------------------------------

programmer # ft232r
    id                     = "ft232r";
    desc                   = "FT232R based generic programmer";
    type                   = "ftdi_syncbb";
    prog_modes             = PM_TPI | PM_ISP;
    is_serialadapter       = yes;
    connection_type        = usb;
    usbvid                 = 0x0403; # For use as serial adapter
    usbpid                 = 0x6001; # "
    reset                  = 4;  # DTR
    sck                    = 0;  # TxD
    sdo                    = 2;  # RTS
    sdi                    = 1;  # RxD
;

#------------------------------------------------------------
# bwmega
#------------------------------------------------------------

# see http://www.bitwizard.nl/wiki/index.php/FTDI_ATmega

programmer # bwmega
    id                     = "bwmega";
    desc                   = "BitWizard ftdi_atmega builtin programmer";
    type                   = "ftdi_syncbb";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x0403;
    usbpid                 = 0x6001;
    reset                  = 7;  # RI
    sck                    = 6;  # DCD
    sdo                    = 3;  # CTS
    sdi                    = 5;  # DSR
;

#------------------------------------------------------------
# arduino-ft232r
#------------------------------------------------------------

# This programmer helps programming the Arduino Diecimila, NG and
# Duemilanove (but not the Uno) without bootloader or external
# programmer using the on-board FT232RL chip. Instructions here:
# https://make.kosakalab.com/arduino/bootloader/index_en.html
# Note that the -c diecimila avrdude.conf entry mentioned in above post
# is the same as the -c arduino-ft232r entry here.

programmer # arduino-ft232r
    id                     = "arduino-ft232r", "diecimila";
    desc                   = "Arduino: FT232R connected to ISP";
    type                   = "ftdi_syncbb";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x0403;
    usbpid                 = 0x6001;
    reset                  = 7;  # RI  X3(4)
    sck                    = 5;  # DSR X3(2)
    sdo                    = 6;  # DCD X3(3)
    sdi                    = 3;  # CTS X3(1)
;

#------------------------------------------------------------
# tc2030
#------------------------------------------------------------

# See https://www.tag-connect.com/product-category/products/cables/ftdi
# for details.

programmer # tc2030
    id                     = "tc2030";
    desc                   = "Tag-Connect TC2030";
    type                   = "ftdi_syncbb";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x0403;
    usbpid                 = 0x6001;
  #                      FOR TPI devices:
    reset                  = 3;  # CTS = D3 (wire to ~RESET)
    sck                    = 2;  # RTS = D2 (wire to SCK)
    sdo                    = 0;  # TxD = D0 (wire to TPIDATA via 1k resistor)
    sdi                    = 1;  # RxD = D1 (wire to TPIDATA directly)
;

#------------------------------------------------------------
# uncompatino
#------------------------------------------------------------

# There is a ATmega328P kit PCB called "uncompatino".
# This board allows ISP via its on-board FT232R.
# This is designed like Arduino Duemilanove but has no standard ICPS header.
# Its 4 pairs of pins are shorted to enable ftdi_syncbb.
# http://akizukidenshi.com/catalog/g/gP-07487/
# http://akizukidenshi.com/download/ds/akizuki/k6096_manual_20130816.pdf

programmer # uncompatino
    id                     = "uncompatino";
    desc                   = "uncompatino with all pairs of pins shorted";
    type                   = "ftdi_syncbb";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x0403;
    usbpid                 = 0x6001;
    reset                  = 7; # ri
    sck                    = 5; # dsr
    sdo                    = 6; # dcd
    sdi                    = 3; # cts
;

#------------------------------------------------------------
# ttl232r
#------------------------------------------------------------

# FTDI USB to serial cable TTL-232R-5V with a custom adapter for ICSP
#  - https://ftdichip.com/product-category/products/cables/usb-ttl-serial-cable-series/
#  - http://www.ftdichip.com/Support/Documents/DataSheets/Cables/DS_TTL-232R_CABLES.pdf
#
# For ICSP pinout see, e.g., http://ww1.microchip.com/downloads/en/DeviceDoc/doc2562.pdf
# (Figure 1. ISP6PIN header pinout and Table 1. Connections required for ISP ...)
# TTL-232R GND 1 Black  -> ICPS GND   (pin 6)
# TTL-232R CTS 2 Brown  -> ICPS SDO   (pin 4)
# TTL-232R VCC 3 Red    -> ICPS VCC   (pin 2)
# TTL-232R TXD 4 Orange -> ICPS RESET (pin 5)
# TTL-232R RXD 5 Yellow -> ICPS SCK   (pin 3)
# TTL-232R RTS 6 Green  -> ICPS SDI   (pin 1)
#
# Except for VCC and GND, you can connect arbitrary pairs as long as the
# following table is adjusted.

programmer # ttl232r
    id                     = "ttl232r";
    desc                   = "FTDI TTL232R-5V with ICSP adapter";
    type                   = "ftdi_syncbb";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x0403;
    usbpid                 = 0x6001;
    reset                  = 0; # txd
    sck                    = 1; # rxd
    sdo                    = 3; # cts
    sdi                    = 2; # rts
;

#------------------------------------------------------------
# usbasp
#------------------------------------------------------------

# From http://www.fischl.de/usbasp
# USBasp is a USB in-circuit programmer for Atmel AVR controllers. It
# simply consists of an ATmega88 or an ATmega8 and a couple of passive
# components. The programmer uses a firmware-only USB driver, no
# special USB controller is needed.
#
# Firmware, schematics and drivers are available under above URL, too.
#
# Alternative firmware for the external programmer:
#
# - https://github.com/mariusgreuel/USBasp
#   Windows OS descriptor to load WinUSB driver automatically
#
# - https://github.com/nerdralph/usbasp
#   WCID compliant, meaning it should work on Windows without any
#   driver or .inf install; default SCK clock of 1.5 MHz and automatic
#   SCK slowing if target does not respond; PORTD is left as input, so
#   this firmware also works with USBISP modules, eg,
#   https://www.sciencetronics.com/greenphotons/?p=938
#
# - https://github.com/dioannidis/usbasp
#   As above plus HID UART support, setting unique serial number and
#   AT89S51/AT89S52 support

programmer # usbasp
    id                     = "usbasp";
    desc                   = "USBasp ISP and TPI programmer";
    type                   = "usbasp";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x16c0; # VOTI
    usbpid                 = 0x05dc; # Obdev's free shared PID
    usbvendor              = "www.fischl.de";
    usbproduct             = "USBasp";
  # Old usbasp from fischl.de:
  # usbvid                 = 0x03EB; # ATMEL
  # usbpid                 = 0xC7B4; # (unoffical) USBasp
  # usbvendor              = "www.fischl.de";
  # usbproduct             = "USBasp";
;

#------------------------------------------------------------
# nibobee
#------------------------------------------------------------

# http://www.nicai-systems.com/en/nibobee

programmer # nibobee
    id                     = "nibobee";
    desc                   = "NIBObee";
    type                   = "usbasp";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x16c0; # VOTI
    usbpid                 = 0x092f; # NIBObee PID
    usbvendor              = "www.nicai-systems.com";
    usbproduct             = "NIBObee";
;

#------------------------------------------------------------
# usbasp-clone
#------------------------------------------------------------

programmer # usbasp-clone
    id                     = "usbasp-clone";
    desc                   = "Any usbasp clone with correct VID/PID";
    type                   = "usbasp";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x16c0; # VOTI
    usbpid                 = 0x05dc; # Obdev's free shared PID
;

#------------------------------------------------------------
# usbtiny
#------------------------------------------------------------

# https://learn.adafruit.com/usbtinyisp
#
# The ISP USBtiny programmer can also be used for TPI programming.
# In that case, a resistor of 1 kOhm is needed between SDI and SDO
# pins of the connector, and SDI (pin 1 of the 6-pin connector)
# connects to TPIDATA.

programmer # usbtiny
    id                     = "usbtiny";
    desc                   = "USBtiny simple USB programmer";
    type                   = "usbtiny";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x1781;
    usbpid                 = 0x0c9f;
;

#------------------------------------------------------------
# arduino_gemma
#------------------------------------------------------------

# https://github.com/arduino/ArduinoCore-avr/tree/master/bootloaders/gemma

programmer # arduino_gemma
    id                     = "arduino_gemma";
    desc                   = "Arduino Gemma bootloader disguised as USBtiny";
    type                   = "usbtiny";
    prog_modes             = PM_SPM;
    connection_type        = usb;
    usbvid                 = 0x2341;
    usbpid                 = 0x0c9f;
;

#------------------------------------------------------------
# adafruit_gemma
#------------------------------------------------------------

# https://github.com/adafruit/Adafruit-Trinket-Gemma-Bootloader

programmer # adafruit_gemma
    id                     = "adafruit_gemma";
    desc                   = "Trinket Gemma bootloader disguised as USBtiny";
    type                   = "usbtiny";
    prog_modes             = PM_SPM;
    connection_type        = usb;
    usbvid                 = 0x1781;
    usbpid                 = 0x0c9f;
;

#------------------------------------------------------------
# arduinoisp
#------------------------------------------------------------

# Arduino LLC branded USBtiny programmer
# https://docs.arduino.cc/retired/boards/arduino-isp/

programmer # arduinoisp
    id                     = "arduinoisp";
    desc                   = "Arduino-branded USBtiny ISP Programmer";
    type                   = "usbtiny";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x2341;
    usbpid                 = 0x0049;
;

#------------------------------------------------------------
# arduinoisporg
#------------------------------------------------------------

# Identical to the Arduino LLC branded USBtiny programmer,
# but with a different USB VID.

programmer # arduinoisporg
    id                     = "arduinoisporg";
    desc                   = "Arduino-branded USBtiny ISP Programmer";
    type                   = "usbtiny";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x2a03;
    usbpid                 = 0x0049;
;

#------------------------------------------------------------
# ehajo-isp
#------------------------------------------------------------

# Commercial version of USBtiny using a separate VID/PID from
# http://www.eHaJo.de (closed from end of 2023)

programmer # ehajo-isp
    id                     = "ehajo-isp";
    desc                   = "AVR ISP programmer from eHaJo.de";
    type                   = "usbtiny";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x16d0;
    usbpid                 = 0x0ba5;
;

#------------------------------------------------------------
# iseavrprog
#------------------------------------------------------------

# Commercial version of USBtiny using a separate VID/PID from
# https://iascaled.com
#
# https://github.com/IowaScaledEngineering/ckt-avrprogrammer

programmer # iseavrprog
    id                     = "iseavrprog";
    desc                   = "AVR ISP programmer from iascaled.com";
    type                   = "usbtiny";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x1209;
    usbpid                 = 0x6570;
;

#------------------------------------------------------------
# micronucleus
#------------------------------------------------------------

# Micronucleus is a bootloader designed for AVR ATtiny
# microcontrollers with a minimal usb interface and a
# strong emphasis on bootloader compactness. See
# https://github.com/micronucleus/micronucleus
# for details.

programmer # micronucleus
    id                     = "micronucleus";
    desc                   = "Micronucleus bootloader";
    type                   = "micronucleus";
    prog_modes             = PM_SPM;
    connection_type        = usb;
    usbvid                 = 0x16d0;
    usbpid                 = 0x0753;
;

#------------------------------------------------------------
# teensy
#------------------------------------------------------------

# Proprietary bootloader used on the AVR based PJRC Teensy boards.
# Can only write to memory, not read/verify.
# See https://www.pjrc.com/teensy/ for details.

programmer # teensy
    id                     = "teensy";
    desc                   = "Teensy bootloader";
    type                   = "teensy";
    prog_modes             = PM_SPM;
    connection_type        = usb;
    usbvid                 = 0x16c0;
    usbpid                 = 0x0478;
;

#------------------------------------------------------------
# ch341a
#------------------------------------------------------------

# Allows programming of AVR parts with F_CPU of min 6.8 MHz with the
# CH341A chip http://www.wch-ic.com/downloads/CH341DS1_PDF.html
#
# See also:
# https://www.onetransistor.eu/2017/08/ch341a-mini-programmer-schematic.html
#
# Connection scheme:
#  CH341A chip -- AVR ISP Connector
#  ~CTS/D0/CS0 -- RESET (can be D1 or D2, see reset setting below)
#  ~DCD/D3/DCK -- SCK
# ~DTR/D5/DOUT -- SDO
#  ~SLP/D7/DIN -- SDI
#          GND -- GND
#           5V -- Vcc/Vin (or disconnect if separately powered)

programmer # ch341a
    id                     = "ch341a";
    desc                   = "CH341A programmer: note AVR F_CPU > 6.8 MHz";
    type                   = "ch341a";
    prog_modes             = PM_ISP;
    is_serialadapter       = yes;
    connection_type        = usb;
    usbvid                 = 0x1a86;
    usbpid                 = 0x5512;
    usbvendor              = "wch.cn";
    usbproduct             = "CH341A";
    reset                  = 0; # Can be 0, 1 or 2 for CS0, CS1 or CS2
;

#------------------------------------------------------------
# butterfly
#------------------------------------------------------------

# Bootloader origininally designed around the AVR Butterfly
# development board. See
# https://www.microchip.com/en-us/development-tool/atavrbfly
# for details.

programmer # butterfly
    id                     = "butterfly";
    desc                   = "Atmel bootloader (Butterfly Development Board)";
    type                   = "butterfly";
    prog_modes             = PM_SPM;
    connection_type        = serial;
;

#------------------------------------------------------------
# avr109
#------------------------------------------------------------

# AVR109 "Butterfly" bootloader.
# See the AVR109 and AVR911 application notes for details.

programmer # avr109
    id                     = "avr109", "avr911";
    desc                   = "Atmel bootloader (AVR109, AVR911)";
    type                   = "butterfly";
    prog_modes             = PM_SPM;
    connection_type        = serial;
;

#------------------------------------------------------------
# butterfly_mk and mkbutterfly
#------------------------------------------------------------

# http://forum.mikrokopter.de

programmer # butterfly_mk
    id                     = "butterfly_mk", "mkbutterfly";
    desc                   = "Mikrokopter.de Butterfly bootloader";
    type                   = "butterfly_mk";
    prog_modes             = PM_SPM;
    connection_type        = serial;
;

#------------------------------------------------------------
# jtagmkI
#------------------------------------------------------------

# The original AVR JTAG ICE. It only supports a handful of
# chips (search for PM_JTAGmkI in this file), but can easily be
# DIY'ed. See doc2475, AVR060, and the following URLs for details:
# https://scienceprog.com/build-your-own-avr-jtagice-clone/
# https://www.olimex.com/Products/AVR/Programmers/AVR-JTAG-USB-A/
# https://www.electrodragon.com/product/avr-usb-jtag-ice-programmer/

programmer # jtagmkI
    id                     = "jtagmkI", "jtag1";
    desc                   = "Atmel JTAG ICE mkI";
    type                   = "jtagmki";
    prog_modes             = PM_JTAGmkI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = serial;
    baudrate               = 115200;    # default is 115200
;

#------------------------------------------------------------
# jtag1slow
#------------------------------------------------------------

programmer parent "jtag1" # jtag1slow
    id                     = "jtag1slow";
    baudrate               = 19200;
;

#------------------------------------------------------------
# jtagmkII
#------------------------------------------------------------

# The JTAG ICE mkII has both, serial and USB connectivity.  As it is
# mostly used through USB these days (AVR Studio 5 only supporting it
# that way), we make connection_type = usb the default.  Users are
# still free to use a serial port with the -P option. See AVR067 or
# https://www.microchip.com/en-us/development-tool/atjtagice2
# for details.

programmer # jtagmkII
    id                     = "jtagmkII";
    desc                   = "Atmel JTAG ICE mkII";
    type                   = "jtagmkii";
    prog_modes             = PM_JTAG | PM_XMEGAJTAG | PM_AVR32JTAG;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    baudrate               = 19200;    # default is 19200
    usbvid                 = 0x03eb;
    usbpid                 = 0x2103;
;

#------------------------------------------------------------
# jtag2slow
#------------------------------------------------------------

programmer parent "jtagmkII" # jtag2slow
    id                     = "jtag2slow";
;

#------------------------------------------------------------
# jtag2fast
#------------------------------------------------------------

# JTAG ICE mkII @ 115200 Bd (and alias jtag2 the fast version)

programmer parent "jtag2slow" # jtag2fast
    id                     = "jtag2fast", "jtag2";
    baudrate               = 115200;
;

#------------------------------------------------------------
# jtag2isp
#------------------------------------------------------------

# JTAG ICE mkII in ISP mode

programmer # jtag2isp
    id                     = "jtag2isp";
    desc                   = "Atmel JTAG ICE mkII in ISP mode";
    type                   = "jtagmkii_isp";
    prog_modes             = PM_TPI | PM_ISP;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    baudrate               = 115200;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2103;
;

#------------------------------------------------------------
# jtag2dw
#------------------------------------------------------------

# JTAG ICE mkII in debugWIRE mode

programmer # jtag2dw
    id                     = "jtag2dw";
    desc                   = "Atmel JTAG ICE mkII in debugWIRE mode";
    type                   = "jtagmkii_dw";
    prog_modes             = PM_debugWIRE;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    baudrate               = 115200;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2103;
;

#------------------------------------------------------------
# jtagmkII_avr32
#------------------------------------------------------------

# JTAG ICE mkII in AVR32 mode

programmer # jtagmkII_avr32
    id                     = "jtagmkII_avr32", "jtag2avr32";
    desc                   = "Atmel JTAG ICE mkII in AVR32 mode";
    type                   = "jtagmkii_avr32";
    prog_modes             = PM_aWire;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    baudrate               = 115200;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2103;
;

#------------------------------------------------------------
# jtag2pdi
#------------------------------------------------------------

# JTAG ICE mkII in PDI mode

programmer # jtag2pdi
    id                     = "jtag2pdi";
    desc                   = "Atmel JTAG ICE mkII in PDI mode";
    type                   = "jtagmkii_pdi";
    prog_modes             = PM_PDI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    baudrate               = 115200;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2103;
;

#------------------------------------------------------------
# dragon_jtag
#------------------------------------------------------------

# AVR Dragon in JTAG mode. See
# https://www.microchip.com/en-us/development-tool/atavrdragon
# for details.

programmer # dragon_jtag
    id                     = "dragon_jtag";
    desc                   = "Atmel AVR Dragon in JTAG mode";
    type                   = "dragon_jtag";
    prog_modes             = PM_JTAG | PM_XMEGAJTAG | PM_AVR32JTAG;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    baudrate               = 115200;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2107;
;

#------------------------------------------------------------
# dragon_isp
#------------------------------------------------------------

# AVR Dragon in ISP mode

programmer # dragon_isp
    id                     = "dragon_isp";
    desc                   = "Atmel AVR Dragon in ISP mode";
    type                   = "dragon_isp";
    prog_modes             = PM_TPI | PM_ISP;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    baudrate               = 115200;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2107;
;

#------------------------------------------------------------
# dragon_pp
#------------------------------------------------------------

# AVR Dragon in PP mode

programmer # dragon_pp
    id                     = "dragon_pp";
    desc                   = "Atmel AVR Dragon in PP mode";
    type                   = "dragon_pp";
    prog_modes             = PM_HVPP;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    baudrate               = 115200;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2107;
;

#------------------------------------------------------------
# dragon_hvsp
#------------------------------------------------------------

# AVR Dragon in HVSP mode

programmer # dragon_hvsp
    id                     = "dragon_hvsp";
    desc                   = "Atmel AVR Dragon in HVSP mode";
    type                   = "dragon_hvsp";
    prog_modes             = PM_HVSP;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    baudrate               = 115200;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2107;
;

#------------------------------------------------------------
# dragon_dw
#------------------------------------------------------------

# AVR Dragon in debugWIRE mode

programmer # dragon_dw
    id                     = "dragon_dw";
    desc                   = "Atmel AVR Dragon in debugWIRE mode";
    type                   = "dragon_dw";
    prog_modes             = PM_debugWIRE;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    baudrate               = 115200;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2107;
;

#------------------------------------------------------------
# dragon_pdi
#------------------------------------------------------------

# AVR Dragon in PDI mode

programmer # dragon_pdi
    id                     = "dragon_pdi";
    desc                   = "Atmel AVR Dragon in PDI mode";
    type                   = "dragon_pdi";
    prog_modes             = PM_PDI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    baudrate               = 115200;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2107;
;

#------------------------------------------------------------
# jtag3
#------------------------------------------------------------

# Atmel JTAGICE3 programmer. See
# https://www.microchip.com/en-us/development-tool/atjtagice3
# for details.
#
# The JTAGICE3 supports the following programming modes
# using different programmer names:
#
# Interface:   Programmer name:
# JTAG         jtag3
# PDI          jtag3pdi
# UPDI         jtag3updi
# debugWIRE    jtag3dw
# ISP          jtag3isp

programmer # jtag3
    id                     = "jtag3";
    desc                   = "Atmel AVR JTAGICE3 in JTAG mode";
    type                   = "jtagice3";
    prog_modes             = PM_JTAG | PM_XMEGAJTAG | PM_AVR32JTAG;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2110, 0x2140;
;

#------------------------------------------------------------
# jtag3pdi
#------------------------------------------------------------

programmer # jtag3pdi
    id                     = "jtag3pdi";
    desc                   = "Atmel AVR JTAGICE3 in PDI mode";
    type                   = "jtagice3_pdi";
    prog_modes             = PM_PDI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2110, 0x2140;
;

#------------------------------------------------------------
# jtag3updi
#------------------------------------------------------------

programmer # jtag3updi
    id                     = "jtag3updi";
    desc                   = "Atmel AVR JTAGICE3 in UPDI mode";
    type                   = "jtagice3_updi";
    prog_modes             = PM_UPDI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2110, 0x2140;
    hvupdi_support         = 1;
;

#------------------------------------------------------------
# jtag3dw
#------------------------------------------------------------

programmer # jtag3dw
    id                     = "jtag3dw";
    desc                   = "Atmel AVR JTAGICE3 in debugWIRE mode";
    type                   = "jtagice3_dw";
    prog_modes             = PM_debugWIRE;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2110, 0x2140;
;

#------------------------------------------------------------
# jtag3isp
#------------------------------------------------------------

programmer # jtag3isp
    id                     = "jtag3isp";
    desc                   = "Atmel AVR JTAGICE3 in ISP mode";
    type                   = "jtagice3_isp";
    prog_modes             = PM_ISP;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2110, 0x2140;
;

#------------------------------------------------------------
# xplainedpro / xplainedpro_jtag
#------------------------------------------------------------

# On-board EDBG based programmer found on various AVR based
# Microchip Xplained Pro boards

# Different Xplained Pro boards uses different programming
# interfaces. These are the ones available:
#
# Interface:   Programmer name:
# JTAG         xplainedpro, xplainedpro_jtag
# PDI          xplainedpro_pdi
# UPDI         xplainedpro_updi

programmer # xplainedpro
    id                     = "xplainedpro", "xplainedpro_jtag";
    desc                   = "Atmel XplainedPro in JTAG mode";
    type                   = "jtagice3";
    prog_modes             = PM_JTAG | PM_XMEGAJTAG | PM_AVR32JTAG;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2111;
;

#------------------------------------------------------------
# xplainedpro_pdi
#------------------------------------------------------------

programmer # xplainedpro_pdi
    id                     = "xplainedpro_pdi";
    desc                   = "Atmel XplainedPro in PDI mode";
    type                   = "jtagice3_pdi";
    prog_modes             = PM_PDI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2111;
    hvupdi_support         = 1;
;

#------------------------------------------------------------
# xplainedpro_updi
#------------------------------------------------------------

programmer # xplainedpro_updi
    id                     = "xplainedpro_updi";
    desc                   = "Atmel XplainedPro in UPDI mode";
    type                   = "jtagice3_updi";
    prog_modes             = PM_UPDI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2111;
    hvupdi_support         = 1;
;

#------------------------------------------------------------
# xplainedmini / xplainedmini_isp
#------------------------------------------------------------

# On-board mEDBG based programmer found on AVR based
# Microchip Xplained Mini/Nano boards
#
# Different Xplained Mini/Nano boards uses different
# programming interfaces. These are the ones available:
#
# Interface:   Programmer name:
# ISP          xplainedmini, xplainedmini_isp
# debugWIRE    xplainedmini_dw
# UPDI         xplainedmini_updi
# TPI          xplainedmini_tpi
#
# Some Xplained Mini boards has a programmable target voltage
# switch that can be controlled using the -xvtarg_switch flag.
# By modifying the SUFFER register using the -xsuffer flag,
# certain programmer safety features can be enabled or disabled.

programmer # xplainedmini
    id                     = "xplainedmini", "xplainedmini_isp";
    desc                   = "Atmel XplainedMini in ISP mode";
    type                   = "jtagice3_isp";
    prog_modes             = PM_ISP;
    extra_features         = HAS_SUFFER | HAS_VTARG_SWITCH;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2145;
;

#------------------------------------------------------------
# xplainedmini_dw
#------------------------------------------------------------

# The Xplained Mini debugWIRE interface may be finicky,
# and usually require the mEDBG chip to drive the XTAL1
# pin on the target to keep the debugWIRE interface
# in sync

programmer # xplainedmini_dw
    id                     = "xplainedmini_dw";
    desc                   = "Atmel XplainedMini in debugWIRE mode";
    type                   = "jtagice3_dw";
    prog_modes             = PM_debugWIRE;
    extra_features         = HAS_SUFFER | HAS_VTARG_SWITCH;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2145;
;

#------------------------------------------------------------
# xplainedmini_updi
#------------------------------------------------------------

# Note that the on-board programmer only support the
# megaAVR-0 and tinyAVR-0/1/2 chip families.

programmer # xplainedmini_updi
    id                     = "xplainedmini_updi";
    desc                   = "Atmel XplainedMini in UPDI mode";
    type                   = "jtagice3_updi";
    prog_modes             = PM_UPDI;
    extra_features         = HAS_SUFFER | HAS_VTARG_SWITCH;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2145;
    hvupdi_support         = 1;
;

#------------------------------------------------------------
# xplainedmini_tpi
#------------------------------------------------------------

programmer # xplainedmini_tpi
    id                     = "xplainedmini_tpi";
    desc                   = "Atmel XplainedMini in TPI mode";
    type                   = "jtagice3_tpi";
    prog_modes             = PM_TPI;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2145;
;

#------------------------------------------------------------
# atmelice / atmelice_jtag
#------------------------------------------------------------

# Atmel-ICE programmer. See
# https://www.microchip.com/en-us/development-tool/atatmel-ice
# for details.
#
# The Atmel-ICE supports the following programming modes
# using different programmer names:
#
# Interface:   Programmer name:
# JTAG         atmelice, atmelice_jtag
# PDI          atmelice_pdi
# UPDI         atmelice_updi
# debugWIRE    atmelice_dw
# ISP          atmelice_isp

programmer # atmelice
    id                     = "atmelice", "atmelice_jtag";
    desc                   = "Atmel-ICE in JTAG mode";
    type                   = "jtagice3";
    prog_modes             = PM_JTAG | PM_XMEGAJTAG | PM_AVR32JTAG;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2141;
;

#------------------------------------------------------------
# atmelice_pdi
#------------------------------------------------------------

programmer # atmelice_pdi
    id                     = "atmelice_pdi";
    desc                   = "Atmel-ICE in PDI mode";
    type                   = "jtagice3_pdi";
    prog_modes             = PM_PDI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2141;
;

#------------------------------------------------------------
# atmelice_updi
#------------------------------------------------------------

programmer # atmelice_updi
    id                     = "atmelice_updi";
    desc                   = "Atmel-ICE in UPDI mode";
    type                   = "jtagice3_updi";
    prog_modes             = PM_UPDI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2141;
    hvupdi_support         = 1;
;

#------------------------------------------------------------
# atmelice_dw
#------------------------------------------------------------

programmer # atmelice_dw
    id                     = "atmelice_dw";
    desc                   = "Atmel-ICE in debugWIRE mode";
    type                   = "jtagice3_dw";
    prog_modes             = PM_debugWIRE;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2141;
;

#------------------------------------------------------------
# atmelice_isp
#------------------------------------------------------------

programmer # atmelice_isp
    id                     = "atmelice_isp";
    desc                   = "Atmel-ICE in ISP mode";
    type                   = "jtagice3_isp";
    prog_modes             = PM_ISP;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2141;
;

#------------------------------------------------------------
# atmelice_tpi
#------------------------------------------------------------

programmer # atmelice_tpi
    id                     = "atmelice_tpi";
    desc                   = "Atmel-ICE in TPI mode";
    type                   = "jtagice3_tpi";
    prog_modes             = PM_TPI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2141;
;

#------------------------------------------------------------
# powerdebugger / powerdebugger_jtag
#------------------------------------------------------------

# Microchip Power Debugger. See
# https://www.microchip.com/en-us/development-tool/atpowerdebugger
# for details.
#
# The Power Debugger supports the following programming modes
# using different programmer names:
#
# Interface:   Programmer name:
# JTAG         powerdebugger, powerdebugger_jtag
# PDI          powerdebugger_pdi
# UPDI         powerdebugger_updi
# debugWIRE    powerdebugger_dw
# ISP          powerdebugger_isp
#
# The Power Debugger has a programmable voltage source and
# can read the target voltage of the connected device.
# It also has two independent current measurement channels.
# All this can be utilized using the Avrdude terminal mode.

programmer # powerdebugger
    id                     = "powerdebugger", "powerdebugger_jtag";
    desc                   = "Atmel PowerDebugger in JTAG mode";
    type                   = "jtagice3";
    prog_modes             = PM_JTAG | PM_XMEGAJTAG | PM_AVR32JTAG;
    extra_features         = HAS_VTARG_ADJ | HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2144;
;

#------------------------------------------------------------
# powerdebugger_pdi
#------------------------------------------------------------

programmer # powerdebugger_pdi
    id                     = "powerdebugger_pdi";
    desc                   = "Atmel PowerDebugger in PDI mode";
    type                   = "jtagice3_pdi";
    prog_modes             = PM_PDI;
    extra_features         = HAS_VTARG_ADJ | HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2144;
;

#------------------------------------------------------------
# powerdebugger_updi
#------------------------------------------------------------

programmer # powerdebugger_updi
    id                     = "powerdebugger_updi";
    desc                   = "Atmel PowerDebugger in UPDI mode";
    type                   = "jtagice3_updi";
    prog_modes             = PM_UPDI;
    extra_features         = HAS_VTARG_ADJ | HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2144;
    hvupdi_support         = 0, 1;
;

#------------------------------------------------------------
# powerdebugger_dw
#------------------------------------------------------------

programmer # powerdebugger_dw
    id                     = "powerdebugger_dw";
    desc                   = "Atmel PowerDebugger in debugWire mode";
    type                   = "jtagice3_dw";
    prog_modes             = PM_debugWIRE;
    extra_features         = HAS_VTARG_ADJ | HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2144;
;

#------------------------------------------------------------
# powerdebugger_isp
#------------------------------------------------------------

programmer # powerdebugger_isp
    id                     = "powerdebugger_isp";
    desc                   = "Atmel PowerDebugger in ISP mode";
    type                   = "jtagice3_isp";
    prog_modes             = PM_ISP;
    extra_features         = HAS_VTARG_ADJ | HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2144;
;

#------------------------------------------------------------
# powerdebugger_tpi
#------------------------------------------------------------

programmer # powerdebugger_tpi
    id                     = "powerdebugger_tpi";
    desc                   = "Atmel PowerDebugger in TPI mode";
    type                   = "jtagice3_tpi";
    prog_modes             = PM_TPI;
    extra_features         = HAS_VTARG_ADJ | HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2144;
;

#------------------------------------------------------------
# pickit4 / pickit4_jtag
#------------------------------------------------------------

# Microchip PICkit 4. For details see
# https://www.microchip.com/en-us/development-tool/pg164140
#
# The PICkit 4 supports the following programming modes
# using different programmer names:
#
# Interface:   Programmer name:
# JTAG         pickit4, pickit4_jtag
# PDI          pickit4_pdi
# UPDI         pickit4_updi
# debugWIRE    pickit4_dw
# ISP          pickit4_isp
#
# The pinout is identical to the MPLAB SNAP, but different
# from other Microchip branded AVR programmers, and would
# usually require an adapter or custom wiring if your target
# board has a standard 6 or 10-pin programming connector.
#
# PIN  JTAG PDI   UPDI  DW   ISP  UART*
# > 1
#   2  VCC  VCC   VCC   VCC  VCC  VCC
#   3  GND  GND   GND   GND  GND  GND
#   4  TDO  DATA  UPDI       SDI
#   5  TCK                   SCK
#   6  RST  SCK         dW   RST
#   7  TDI                   SDO  TX (target)
#   8  TMS                        RX (target)
#
# * The PICkit4 can also be used as a USB to UART
# interface for simple serial debugging.

programmer # pickit4
    id                     = "pickit4", "pickit4_jtag";
    desc                   = "MPLAB(R) PICkit 4 in JTAG mode";
    type                   = "jtagice3";
    prog_modes             = PM_JTAG | PM_XMEGAJTAG;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2177, 0x2178, 0x2179;
;

#------------------------------------------------------------
# pickit4_updi
#------------------------------------------------------------

programmer # pickit4_updi
    id                     = "pickit4_updi";
    desc                   = "MPLAB(R) PICkit 4 in UPDI mode";
    type                   = "jtagice3_updi";
    prog_modes             = PM_UPDI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2177, 0x2178, 0x2179;
    hvupdi_support         = 0, 1, 2;
;

#------------------------------------------------------------
# pickit4_pdi
#------------------------------------------------------------

programmer # pickit4_pdi
    id                     = "pickit4_pdi";
    desc                   = "MPLAB(R) PICkit 4 in PDI mode";
    type                   = "jtagice3_pdi";
    prog_modes             = PM_PDI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2177, 0x2178, 0x2179;
;

#------------------------------------------------------------
# pickit4_isp
#------------------------------------------------------------

# Due to hardware limitations, the PICkit 4 can only
# reach an ISP clock speed of about 330 kHz

programmer # pickit4_isp
    id                     = "pickit4_isp";
    desc                   = "MPLAB(R) PICkit 4 in ISP mode";
    type                   = "jtagice3_isp";
    prog_modes             = PM_ISP;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2177, 0x2178, 0x2179;
;

#------------------------------------------------------------
# pickit4_tpi
#------------------------------------------------------------

programmer # pickit4_tpi
    id                     = "pickit4_tpi";
    desc                   = "MPLAB(R) PICkit 4 in TPI mode";
    type                   = "jtagice3_tpi";
    prog_modes             = PM_TPI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2177, 0x2178, 0x2179;
;


# Microchip PICkit 5. For details, see
# https://www.microchip.com/en-us/development-tool/PG164150
#
# Currently -c pickit5 only supports UPDI programming
#
# PIN  UPDI  
# > 1  !RST(*)
#   2  VCC
#   3  GND
#   4  UPDI(*)
#   5
#   6
#   7
#   8                       
#
# (*): The PICkit5 can generate a High-Voltage (12V) Pulse on this pins
#      to restore the UPDI Pin functionality, if it was changed through fuses.
#      AVRDUDE automatically selects the correct pin, if the HV pulse is
#      enabled through the '-x hvupdi' flag.

#------------------------------------------------------------
# pickit5 /pickit5_updi
#------------------------------------------------------------

programmer # pickit5_updi
    id                     = "pickit5_updi";
    desc                   = "MPLAB(R) PICkit 5, PICkit 4 and SNAP (PIC)";
    type                   = "pickit5_updi";
    prog_modes             = PM_UPDI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    baudrate               = 200000;   # UPDI default clock
    usbvid                 = 0x04d8;
    usbpid                 = 0x9036, 0x9012, 0x9018; # PK5, PK4 (pic mode), snap (pic mode)
    hvupdi_support         = 0, 1, 2;
;

#------------------------------------------------------------
# snap /snap_jtag
#------------------------------------------------------------

# Microchip MPLAB SNAP. See
# https://www.microchip.com/en-us/development-tool/pg164100
# for details.
#
# The MPLAB SNAP supports the following programming modes
# using different programmer names:
#
# Interface:   Programmer name:
# JTAG         snap, snap_jtag
# PDI          snap_pdi
# UPDI         snap_updi
# debugWIRE    snap_dw
# ISP          snap_isp
#
# The pinout is identical to the PICkit 4, but different
# from other Microchip branded AVR programmers, and would
# usually require an adapter or custom wiring if your target
# board has a standard 6 or 10-pin programming connector.
#
#   PIN  JTAG PDI   UPDI  DW   ISP  UART*
#   > 1
#     2  VCC  VCC   VCC   VCC  VCC  VCC
#     3  GND  GND   GND   GND  GND  GND
#     4  TDO  DATA  UPDI       SDI
#     5  TCK                   SCK
#     6  RST  SCK         dW   RST
#     7  TDI                   SDO  TX (target)
#     8  TMS                        RX (target)
#
# * The MPLAB SNAP can also be used as a USB to UART
#   interface for simple serial debugging.

programmer # snap
    id                     = "snap", "snap_jtag";
    desc                   = "MPLAB(R) SNAP in JTAG mode";
    type                   = "jtagice3";
    prog_modes             = PM_JTAG | PM_XMEGAJTAG;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2180, 0x217f, 0x2181;
;

#------------------------------------------------------------
# snap_updi
#------------------------------------------------------------

# Note that certain MPLAB SNAP programmer needs a hardware
# modification to be used as a UPDI programmer.
# See the Microchip ETN #36 for details.

programmer # snap_updi
    id                     = "snap_updi";
    desc                   = "MPLAB(R) SNAP in UPDI mode";
    type                   = "jtagice3_updi";
    prog_modes             = PM_UPDI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2180, 0x217f, 0x2181;
    hvupdi_support         = 1;
;

#------------------------------------------------------------
# snap_pdi
#------------------------------------------------------------

programmer # snap_pdi
    id                     = "snap_pdi";
    desc                   = "MPLAB(R) SNAP in PDI mode";
    type                   = "jtagice3_pdi";
    prog_modes             = PM_PDI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2180, 0x217f, 0x2181;
;

#------------------------------------------------------------
# snap_isp
#------------------------------------------------------------

# Due to hardware limitations, the MPLAB SNAP can only
# reach an ISP clock speed of about 330 kHz

programmer # snap_isp
    id                     = "snap_isp";
    desc                   = "MPLAB(R) SNAP in ISP mode";
    type                   = "jtagice3_isp";
    prog_modes             = PM_ISP;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2180, 0x217f, 0x2181;
;

#------------------------------------------------------------
# snap_tpi
#------------------------------------------------------------

programmer # snap_tpi
    id                     = "snap_tpi";
    desc                   = "MPLAB(R) SNAP in TPI mode";
    type                   = "jtagice3_tpi";
    prog_modes             = PM_TPI;
    extra_features         = HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2180, 0x217f, 0x2181;
;

#------------------------------------------------------------
# pkobn_updi
#------------------------------------------------------------

# Microchip PICkit On-Board Nano is the name of the nEDBG
# based programmer/debugger that's found on AVR based
# Curiosity Nano boards.
#
# These boards can read and adjust the target voltage supply
# and can be done in the Avrdude terminal mode.

programmer # pkobn_updi
    id                     = "pkobn_updi";
    desc                   = "Curiosity nano (nEDBG) in UPDI mode";
    type                   = "jtagice3_updi";
    prog_modes             = PM_UPDI;
    extra_features         = HAS_VTARG_ADJ | HAS_VTARG_READ;
    connection_type        = usb;
    usbvid                 = 0x03eb;
    usbpid                 = 0x2175;
    hvupdi_support         = 1;
;

#------------------------------------------------------------
# pavr
#------------------------------------------------------------

# AVR910 based programmer. See
# https://web.archive.org/web/20040803005703/http://avr1.org/pavr/pavr.html
# for details.

programmer # pavr
    id                     = "pavr";
    desc                   = "Jason Kyle's pAVR Serial Programmer";
    type                   = "avr910";
    prog_modes             = PM_ISP;
    connection_type        = serial;
;

#------------------------------------------------------------
# pickit2
#------------------------------------------------------------

# Microchip PICkit 2. See
# https://www.microchip.com/en-us/development-tool/pg164120
# for details.
#
#   PIN  ISP
#   > 1  RST
#     2  VCC
#     3  GND
#     4  SDI
#     5  SCK
#     6  SDO

programmer # pickit2
    id                     = "pickit2";
    desc                   = "Microchip PICkit 2 programmer in ISP mode";
    type                   = "pickit2";
    prog_modes             = PM_ISP;
    connection_type        = usb;
    usbvid                 = 0x04d8;
    usbpid                 = 0x0033;
;

#------------------------------------------------------------
# flip1
#------------------------------------------------------------

# The Atmel "Flexible in-system programmer" (FLIP v1) is a
# USB DFU bootloader designed for 8-bit AVRs with a native
# USB interface.
# See doc7618 for more information.

programmer # flip1
    id                     = "flip1";
    desc                   = "FLIP bootloader using USB DFU v1 (doc7618)";
    type                   = "flip1";
    prog_modes             = PM_SPM;
    connection_type        = usb;
    usbvid                 = 0x03eb;
;

#------------------------------------------------------------
# flip2
#------------------------------------------------------------

# The Atmel "Flexible in-system programmer" (FLIP v2) is a
# USB DFU bootloader designed for AVR XMEGA and AVR32.
# See AVR4023 for more information.

programmer # flip2
    id                     = "flip2";
    desc                   = "FLIP bootloader using USB DFU v2 (AVR4023)";
    type                   = "flip2";
    prog_modes             = PM_SPM;
    connection_type        = usb;
    usbvid                 = 0x03eb;
;

#------------------------------------------------------------
# ponyser
#------------------------------------------------------------

# some ultra cheap programmers use bitbanging on the serialport
#
# PC - DB9 - Pins for RS232:
#
# GND   5   -- |O
#              |   O| <-   9   RI
# DTR   4   <- |O   |
#              |   O| <-   8   CTS
# TXD   3   <- |O   |
#              |   O| ->   7   RTS
# RXD   2   -> |O   |
#              |   O| <-   6   DSR
# DCD   1   -> |O
#
# Using RXD is currently not supported.
# Using RI is not supported under Win32 but is supported under Posix.

# serial ponyprog design (dasa2 in uisp)
# reset=!txd sck=rts sdo=dtr sdi=cts

programmer # ponyser
    id                     = "ponyser";
    desc                   = "ponyprog serial: reset=!txd sck=rts sdo=dtr sdi=cts";
    type                   = "serbb";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = serial;
    reset                  = ~3;
    sck                    = 7;
    sdo                    = 4;
    sdi                    = 8;
;

#------------------------------------------------------------
# siprog
#------------------------------------------------------------

# Serial port adapter http://www.lancos.com/siprogsch.html
# Same as above, different name

programmer parent "ponyser" # siprog
    id                     = "siprog";
    desc                   = "Lancos SI-Prog (same as ponyser)";
;

#------------------------------------------------------------
# dasa
#------------------------------------------------------------

# unknown (dasa in uisp)
# reset=rts sck=dtr sdo=txd sdi=cts

programmer # dasa
    id                     = "dasa";
    desc                   = "serial port: reset=rts sck=dtr sdo=txd sdi=cts";
    type                   = "serbb";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = serial;
    reset                  = 7;
    sck                    = 4;
    sdo                    = 3;
    sdi                    = 8;
;

#------------------------------------------------------------
# dasa3
#------------------------------------------------------------

# unknown (dasa3 in uisp)
# reset=!dtr sck=rts sdo=txd sdi=cts

programmer # dasa3
    id                     = "dasa3";
    desc                   = "serial port: reset=!dtr sck=rts sdo=txd sdi=cts";
    type                   = "serbb";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = serial;
    reset                  = ~4;
    sck                    = 7;
    sdo                    = 3;
    sdi                    = 8;
;

#------------------------------------------------------------
# C2N232i
#------------------------------------------------------------

# C2N232i (jumper configuration "auto")
# reset=dtr sck=!rts sdo=!txd sdi=!cts

programmer # c2n232i
    id                     = "c2n232i";
    desc                   = "serial port: reset=dtr sck=!rts sdo=!txd sdi=!cts";
    type                   = "serbb";
    prog_modes             = PM_TPI | PM_ISP;
    connection_type        = serial;
    reset                  = 4;
    sck                    = ~7;
    sdo                    = ~3;
    sdi                    = ~8;
;

#------------------------------------------------------------
# jtag2updi
#------------------------------------------------------------

# https://github.com/ElTangas/jtag2updi
# Original source for the jtag2updi project
#
# https://github.com/askn37/jtag2updi
# Enhanced firmware with better device support
#
# https://github.com/arduino/ArduinoCore-megaavr/tree/master/firmwares/MuxTO
# Arduino Nano Every (jtag2updi with 1200 baud touch, -r)

programmer # jtag2updi
    id                     = "jtag2updi", "nanoevery";
    desc                   = "JTAGv2 to UPDI bridge";
    type                   = "jtagmkii_updi";
    prog_modes             = PM_UPDI;
    connection_type        = serial;
    baudrate               = 115200;
    hvupdi_support         = 1;
;

#
# SERIAL ADAPTER DEFINITIONS
#

# A serialadapter is a programmer that has only USB parameters defined; it
# can be used for a -P <serialadapter>[:<serial number>] port
# specification instead of the created serial port. Per-user serialadapter
# definitions in ~/.avrduderc or avrdude.rc files can add a serial number
# to assign a particular board a specific id and default baud rate:
#
# serialadapter parent "ft232r"
#     id                     = "bike-shed-door";
#     usbsn                  = "0123456789";
#     baudrate               = 250000;
# ;
#
# This is particularly useful for programming via a bootloader as it allows
# specifying the port as -P bike-shed-door rather than having to figure out
# which serial port name the operating system has assigned to the plugged in
# bike-shed-door board at runtime. Note that each programmer that defines
# usbpid and sets is_serialadapter = yes can also be utilised as a
# serialadapter.

#------------------------------------------------------------
# ch340
#------------------------------------------------------------

serialadapter # ch340
    id                     = "ch340";
    desc                   = "WCH CH340 USB to serial adapter";
    usbvid                 = 0x1a86;
    usbpid                 = 0x7523;
;

#------------------------------------------------------------
# ch342
#------------------------------------------------------------

# Dual serial port chip
# https://www.wch-ic.com/products/CH342.html

serialadapter # ch342
    id                     = "ch342";
    desc                   = "WCH CH342 USB to serial adapter";
    usbvid                 = 0x1a86;
    usbpid                 = 0x55d2;
;

#------------------------------------------------------------
# ch343
#------------------------------------------------------------

# CH343 doc https://www.wch-ic.com/downloads/CH343DS1_PDF.html

serialadapter # ch343
    id                     = "ch343";
    desc                   = "WCH CH343 USB to serial adapter";
    usbvid                 = 0x1a86;
    usbpid                 = 0x55d3;
;

#------------------------------------------------------------
# ch344
#------------------------------------------------------------

# Quad serial port chip
# https://www.wch-ic.com/products/CH344.html

serialadapter # ch344
    id                     = "ch344";
    desc                   = "WCH CH344 USB to serial adapter";
    usbvid                 = 0x1a86;
    usbpid                 = 0x55d5;
;

#------------------------------------------------------------
# ch347
#------------------------------------------------------------

# Multipurpose interface chip
# https://www.wch-ic.com/products/CH347.html

serialadapter # ch347
    id                     = "ch347";
    desc                   = "WCH CH347 USB to serial adapter";
    usbvid                 = 0x1a86;
    usbpid                 = 0x55da, 0x55db, 0x55dd, 0x55de;
;

#------------------------------------------------------------
# ch9102
#------------------------------------------------------------

serialadapter # ch9102
    id                     = "ch9102";
    desc                   = "WCH CH9102 USB to serial adapter";
    usbvid                 = 0x1a86;
    usbpid                 = 0x55d4;
;

#------------------------------------------------------------
# ch9103
#------------------------------------------------------------

# Dual serial port chip
# https://www.wch-ic.com/products/CH9103.html

serialadapter # ch9103
    id                     = "ch9103";
    desc                   = "WCH CH9103 USB to serial adapter";
    usbvid                 = 0x1a86;
    usbpid                 = 0x55d7;
;

#------------------------------------------------------------
# cp210x
#------------------------------------------------------------

serialadapter # cp210x
    id                     = "cp210x";
    desc                   = "Silabs CP210x USB to serial adapter";
    usbvid                 = 0x10c4;
    usbpid                 = 0xea60, 0xea70, 0xea71;
;

#------------------------------------------------------------
# ft231x / ft234x / ft230x
#------------------------------------------------------------

serialadapter # ft231x
    id                     = "ft231x", "ft234x", "ft230x";
    desc                   = "FTDI FT23X series USB to serial adapter";
    usbvid                 = 0x0403;
    usbpid                 = 0x6015;
;

#------------------------------------------------------------
# pl2303
#------------------------------------------------------------

serialadapter # pl2303
    id                     = "pl2303";
    desc                   = "Profilic PL2303 USB to serial adapter";
    usbvid                 = 0x067b;
    usbpid                 = 0x2303, 0x2304, 0x23a3, 0x23b3, 0x23c3, 0x23d3, 0x23e3, 0x23f3;
;